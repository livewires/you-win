<!doctype html>
<meta charset=utf-8>
<meta name=viewport content="width=device-width, initial-scale=1.0">
<title>you-win: API Reference</title>

<style>
body, div, p, textarea, pre, ul, ol, li, blockquote, hr,table, tbody, thead, tr, td, th,h1, h2, h3, h4, h5, a, button, input {margin: 0;padding: 0;border: 0;font: inherit;color: inherit;list-style: none;text-decoration: none;}strong {font-weight: 600;}em {font-style: italic;color: #555;}* {line-height: 1.5;}a {white-space: normal;cursor: pointer;}body {font-family: Open Sans, BlinkMacSystemFont, -apple-system, Helvetica Neue, Ubuntu, Arial, Helvetica, sans-serif;font-size: 1rem;background: #fff;color: #000;font-size: 16px;min-height: calc(100vh - 2em);}p {margin: 0.75em 0;}body {margin: 1.5em auto 6em;padding: 0 2em;max-width: 72em;position: relative;}.emojione {width: 1.25em;height: 1.25em;line-height: 0.8em;}.prose {font-size: 1rem;max-width: 36em;font-weight: normal;margin: 0 auto;}.prose a {color: #3786e3;text-decoration: none;border-bottom: 1px solid #3786e3;}.prose h1 {font-weight: 300;font-size: 2rem;}.prose h2 {font-weight: 500;font-size: 1.5em;margin: 1.333em 0 0;border-top: 2px solid #ddd;padding-top: 0.666em;}.prose h3 {font-weight: 600;font-size: 1.25em;margin: 2em 0 0;}.prose pre, .prose code {border-radius: 0.25em;background: #f8f8f8;font-size: 0.875em;line-height: 1.5em;font-family: Menlo, monospace;}.prose pre {max-width: 100%;white-space: pre-wrap;margin: 1.09375em 0;overflow: hidden;padding: 0.25em 0.5em;}.prose code {padding: 0.125em;}.prose pre code {display: block;white-space: pre-wrap;border: none;padding: 0;background-color: transparent;border-radius: 0;font-size: inherit;line-height: inherit;}.prose > p {margin: 1.5em 0;}.prose > ul, .prose ol {margin: 1.5em 0;}.prose ul, .prose ol {padding-left: 1.875em;position: relative;}.prose ul > li {list-style: square;}.prose ol > li {list-style: none;counter-increment: step-count;}.prose ol > li:before {content: counter(step-count);font-weight: 500;display: inline-block;position: absolute;left: 0.5em;}.prose img,.prose video {max-width: 100%;object-fit: scale-down;height: auto;}.prose blockquote {margin: 1.5em 0;border-left: 0.25em solid #555;padding-left: 1em;color: #222;}@media print {body {max-width: 100%;font-size: 12pt;}.prose a {border-bottom: none;}.prose {margin: 0 auto;}nav {display: none;}pre, blockquote {padding-right: 1em;page-break-inside: avoid;}tr, img {page-break-inside: avoid;}@page {margin: 20mm 15mm 20mm 15mm;}p, h2, h3 {orphans: 3;widows: 3;}h2, h3 {page-break-after: avoid;}.prose pre {border-left: 2px solid #ccc;padding-left: 0.75em;border-radius: 0;page-break-after: avoid;}}nav {margin: -0.5em -2em;border-bottom: 1px solid #aaa;margin-bottom: 1.5em;color: #364149;}nav ul {padding: 0;margin: 0;}nav a {color: inherit;text-decoration: none;display: block;overflow: hidden;text-overflow: ellipsis;padding: 0.375em 2em;white-space: nowrap;}.title a {font-size: 2rem;padding: 0 1em;font-weight: 300;}.page {display: block;}.page-title-active,.page-heading-active {color: #3786e3;}.page-heading {display: block;padding-left: 1.5em;}@media screen and (min-width: 36rem) {body.has-nav {margin-left: 12rem;}nav {margin: 0;position: fixed;width: 12rem;left: 0;top: 0;bottom: 0;overflow-y: auto;font-size: 0.875em;border-right: 1px solid #aaa;background: #fafafa;border-bottom: 0;}nav a {padding: 0.375em 1em;}.title a {padding: 0.75em 0.5em 0.625em;}nav > ul {position: relative;min-height: 100vh;padding-bottom: 6em;box-sizing: border-box;}.page-as-pdf {position: absolute;bottom: 3em;}.logo {position: absolute;bottom: 1em;display: block;background: url("data:image/svg+xml,<svg viewBox='10 0 38 7' xmlns='http://www.w3.org/2000/svg'><path fill='%233786e3' d='M17 3h-1V1h1zM18 5h-1V3h1zM20 5h-1V3h1zM21 3h-1V1h1zM11 5h2v1h-3V1h1zM25 2h-2v1h2v1h-2v1h2v1h-3V1h3zM14 6V1h1v5zM18 5h1v1h-1z'/><path d='M42 2h-2v1h2v1h-2v1h2v1h-3V1h3zM30 5V1h1v4zM28 5V2h1v3zM32 6V1h1v5zM43 2h1v1h-1zM44 3h2v1h-2zM43 5h3v1h-3zM44 1h3v1h-3zM46 4h1v1h-1zM26 5V1h1v4zM27 5h1v1h-1zM29 5h1v1h-1zM34 6V1h3v1h-2v1h2v2h-1V4h-1v2zM37 5h1v1h-1zM37 2h1v1h-1z'/></svg>") 100% 0 no-repeat;margin: 0.5em 1em 0;height: 14px;width: 76px;}.logo span {display: none;}}.hljs { display: block; background: white; padding: 0.5em; color: #333333; overflow-x: auto; } .hljs-comment, .hljs-meta { color: #969896; } .hljs-string, .hljs-variable, .hljs-template-variable, .hljs-strong, .hljs-emphasis, .hljs-quote { color: #df5000; } .hljs-keyword, .hljs-selector-tag, .hljs-type { color: #a71d5d; } .hljs-literal, .hljs-symbol, .hljs-bullet, .hljs-attribute { color: #0086b3; } .hljs-section, .hljs-name { color: #63a35c; } .hljs-tag { color: #333333; } .hljs-title, .hljs-attr, .hljs-selector-id, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo { color: #795da3; } .hljs-addition { color: #55a532; background-color: #eaffea; } .hljs-deletion { color: #bd2c00; background-color: #ffecec; } .hljs-link { text-decoration: underline; }
</style>

<body class=has-nav>

<nav id=nav>
    <ul>
        <h1 class=title><a href="https://github.com/livewires/you-win">you-win</a></h1>

        <li class=page><a href="install">Install</a>
        <li class=page><a href="1-numbers">#1: Numbers</a>
        <li class=page><a href="2-animation">#2: Animation</a>
        <li class=page><a href="3-arrays">#3: Arrays</a>
        <li class=page><a href="4-functions">#4: Functions</a>
        <li class=page><a href="jump">Game</a>
        <li class=page>
            <a href="#" class=page-title-active>API Reference</a>
            <ul>
                <li class=page-heading><a href="#importing">Importing</a>
                <li class=page-heading><a href="#assets">Assets</a>
                <li class=page-heading><a href="#world">World</a>
                <li class=page-heading><a href="#sprite">Sprite</a>
                <li class=page-heading><a href="#spriteforever">Sprite::forever</a>
                <li class=page-heading><a href="#text">Text</a>
                <li class=page-heading><a href="#polygon">Polygon</a>
                <li class=page-heading><a href="#rect">Rect</a>
                <li class=page-heading><a href="#touch-events">Touch Events</a>
                <li class=page-heading><a href="#touches-list">Touches list</a>
                <li class=page-heading><a href="#phone">Phone</a>
                <li class=page-heading><a href="#sound">Sound</a>
            </ul>
        </li>

        <a class=page-as-pdf href="pdfs/reference.pdf">Page as PDF ‚Üì</a>
        <a class=logo href="http://livewires.org.uk/"></a>
    </ul>
</nav>

<div class=prose>
<h1 id="you-win-api-reference">you-win: API Reference</h1>
<h2 id="importing">Importing</h2>
<p><code>you-win</code> exports the following names:</p>
<ul>
<li><a href="#assets">init</a></li>
<li><a href="#world">World</a></li>
<li><a href="#sprite">Sprite</a></li>
<li><a href="#text">Text</a></li>
<li><a href="#polygon">Polygon</a></li>
<li><a href="#phone">Phone</a></li>
<li><a href="#sound">Sound</a></li>
</ul>
<p>To import all these names so you can use them in your code, use the following lines:</p>
<pre><code class="language-js">const uw = require(&#39;you-win&#39;)
const {Phone, World, Sprite, Text, Polygon} = uw</code></pre>
<h2 id="assets">Assets</h2>
<p>Before you can do anything, you need initialise <code>you-win</code>. You do this by calling <strong><code>uw.begin()</code></strong>, which downloads <strong>all the files your game needs</strong>. We display a progress bar while your files are downloading.</p>
<pre><code class="language-js">await uw.begin()</code></pre>
<p>The special <strong><code>await</code></strong> keyword is important here: it tells the computer not to carry on with your program until everything has finished loading.</p>
<p>You should call begin() <strong>exactly once</strong>.</p>
<h3 id="costumes">Costumes</h3>
<p>A costume is an image that controls how a <code>Sprite</code> looks.</p>
<p>You download them by calling <strong><code>loadCostume()</code></strong> with a name and URL, <strong>before</strong> you call <code>begin()</code>.</p>
<p>If you make a <strong><code>static</code> folder</strong> in the same place as your game‚Äôs <code>.js</code> file, you can put images inside it, and then use <code>&#39;/&lt;filename&gt;&#39;</code> to load them. For example, if you put <code>my-asteroid.png</code> in the <code>static</code> folder:</p>
<pre><code class="language-js">uw.loadCostume(&#39;asteroid&#39;, &#39;/my-asteroid.png&#39;)
await uw.begin()</code></pre>
<p>You can also use assets from a <strong><a href="https://glitch.com">Glitch</a></strong> project. Copy their URL into your program:</p>
<pre><code class="language-js">uw.loadCostume(&#39;face&#39;, &#39;https://cdn.glitch.com/f213ed6a-d103-4816-b60d-47c712a926e2%2Fcat_00.png&#39;)
await uw.begin()</code></pre>
<blockquote>
<p>‚ö† Because of security restrictions, you can‚Äôt use just any image URL from any website.</p>
</blockquote>
<p>To use a costume later, give its <strong>name</strong>:</p>
<pre><code class="language-js">var s = new Sprite
s.costume = &#39;asteroid&#39;</code></pre>
<p>If you load more than one costumes, <code>you-win</code> won‚Äôt wait until the first one finishes downloading before downloading the next one. It speeds things up by downloading them all at once (i.e. in <strong>parallel</strong>).</p>
<pre><code class="language-js">uw.loadCostume(&#39;duck1&#39;, &#39;/duck-frame1.png&#39;)
uw.loadCostume(&#39;duck2&#39;, &#39;/duck-frame2.png&#39;)
await uw.begin() // waits for duck1 and duck2 to finish downloading</code></pre>
<h3 id="emoji-costumes">Emoji costumes</h3>
<p>Emoji costumes are loaded by default. To use them, just set your Sprite‚Äôs <code>.costume</code> attribute to an emoji string:</p>
<pre><code class="language-js">var s = new Sprite
s.costume = &#39;<img class="emojione" alt="üôÇ" title=":slight_smile:" src="https://cdn.jsdelivr.net/emojione/assets/3.1/png/32/1f642.png"/>&#39;</code></pre>
<p>The emoji costumes are sized 32x32 pixels. Most but not all emoji are included.</p>
<p>Emoji make great placeholder graphics for your game, or even final graphics if you like the retro pixel-art theme.</p>
<p>You can also use emoji inside <a href="#text">Text</a>.</p>
<h2 id="world">World</h2>
<p><strong><code>World</code></strong> sets up the screen, manages all the sprites, and emits events such as taps and drags on the background.</p>
<p>Set up the world after <a href="#assets">calling <code>begin()</code></a> to load your assets.</p>
<pre><code class="language-js">// Load everything we need
await uw.begin()

// Make the world
var world = new World
world.title = &#39;&#39;
world.background = &#39;white&#39;

// Now we can start making Sprites!</code></pre>
<p>It has the following attributes:</p>
<ul>
<li><p><strong><code>world.width</code> / <code>world.height</code></strong></p>
<p>The size of the game‚Äôs visible area on the screen.</p>
<p>If you don‚Äôt provide a width or height when making your world, it will default to using the size of the phone‚Äôs screen.</p>
</li>
<li><p><strong><code>world.scrollX</code> / <code>world.scrollY</code></strong></p>
<p>An offset applied to all of the objects on-screen.</p>
<p>You can change these in order to move around the virtual ‚Äúcamera‚Äù to show different parts of the world, e.g. for writing a platformer.</p>
<p>But be aware, the X and Y positions of your sprites won‚Äôt change when you scroll; so a sprite at <em>(0, 0)</em> will no longer be in the bottom-left corner of the screen!</p>
</li>
<li><p><strong><code>world.background</code></strong></p>
<p>The background colour of the world. Uses HTML/CSS colours, such as <code>red</code> or <code>#007de0</code>.</p>
</li>
</ul>
<p>World has the following methods:</p>
<ul>
<li><strong><code>world.stop()</code></strong></li>
</ul>
<h2 id="sprite">Sprite</h2>
<p>A <strong><code>Sprite</code></strong> is an image in the world that can be moved and rotated and so on.</p>
<p>To make your Sprite appear, you must set its <code>costume</code>.</p>
<pre><code class="language-js">uw.loadCostume(&#39;cat&#39;, &#39;https://cdn.glitch.com/f213ed6a-d103-4816-b60d-47c712a926e2%2Fcat_00.png?1499126150626&#39;)
await uw.begin()

var world = new World

var cat = new Sprite
cat.costume = &#39;cat&#39;

var bigCat = new Sprite
bigCat.costume = &#39;cat&#39;
bigCat.scale = 2 // twice as big</code></pre>
<p>Sprites have quite a few attributes which you can change. You can also set their initial values when you make the sprite.</p>
<ul>
<li><p><strong><code>sprite.posX</code></strong> / <strong><code>sprite.posY</code></strong></p>
<p>The X and Y co-ordinates of the center of the sprite, starting from the bottom-left corner of the screen.</p>
</li>
<li><p><strong><code>sprite.angle = 0</code></strong></p>
<p>The rotation of the sprite, going clockwise.</p>
<img src="static/sprite-xy.png" width=240>
<img src="static/sprite-angle.png" width=180>
</li>
<li><p><strong><code>sprite.scale = 1.0</code></strong></p>
<p>The scale factor of the sprite. <code>1.0</code> means 100%; <code>2.0</code> is twice the size; <code>0.5</code> is half the size.</p>
</li>
<li><p><strong><code>sprite.flipped = false</code></strong></p>
<p>Either <code>true</code> or <code>false</code>.</p>
<p>Whether to flip the sprite‚Äôs costume, so that it faces the other way. Defaults to `false.</p>
</li>
<li><p><strong><code>sprite.opacity = 1.0</code></strong></p>
<p>Controls the sprite‚Äôs opacity aka. alpha aka. transparency aka. ‚Äúghost‚Äù effect.</p>
<p>A value of <code>1.0</code> means the sprite is fully <strong>opaque</strong>; <code>0.0</code> means the sprite is fully see-through.</p>
<p>If you want to remove the sprite entirely and permanently, use <code>destroy()</code>.</p>
</li>
<li><p><strong><code>sprite.costume = &#39;poop&#39;</code></strong></p>
<p>The image to use for the sprite, in case you want to change it later. For example, if you want to cycle between several images in order to ‚Äúanimate‚Äù the sprite‚Äù.</p>
<p>You can also give an emoji here, to get one of the built-in emoji costumes (assuming <code>you-win</code> supports that emoji).</p>
</li>
<li><p><strong><code>sprite.left</code></strong> / <strong><code>sprite.right</code></strong> / <strong><code>sprite.top</code></strong> / <strong><code>sprite.bottom</code></strong></p>
<p>The co-ordinates of the edges of the <em>bounding box</em> of the sprite. The bounding box is an <em>axis-aligned</em> box enclosing the whole sprite.</p>
<p><strong>TODO</strong>: diagram</p>
<p>These can be useful for getting or changing the position of the edge of a sprite. They tend to be more useful for non-rotated sprites.</p>
<blockquote>
<p><strong>Important:</strong> you usually need to assign these last. If you set the the position of an edge, and then for example change the <code>scale</code>, the edge won‚Äôt line up anymore! So make sure you set edge positions after setting the other attributes.</p>
</blockquote>
</li>
</ul>
<!--
  * **`sprite.xOffset`** / **`sprite.yOffset`**

    The offset between the sprite's position, and the bottom-left corner of the sprite. The default is minus half the width and height of the costume, respectively, so that the sprite's costume is centered on the sprite's position.

    Usually you don't need to change this.
-->


<p>Sprites have some useful functions attached to them.</p>
<ul>
<li><p><strong><code>sprite.raise()</code></strong></p>
<p>Bring the sprite to the front, so that it is above all the other sprites.</p>
</li>
<li><p><strong><code>sprite.lower()</code></strong></p>
<p>Send the sprite to the back, below all the other sprites.</p>
</li>
<li><p><strong><code>sprite.getTouching()</code></strong></p>
<p>Returns a list of sprites which are overlapping this one.</p>
<p>Useful for detecting collisions!</p>
<pre><code class="language-js">for (var other of player.getTouching()) {
    if (other.isBullet) {
        // lose some health
    }
}</code></pre>
</li>
<li><p><strong><code>sprite.getTouchingFast()</code></strong></p>
<p>The same as <code>getTouching</code>, but avoids the accurate-but-slow Scratch-like pixel-perfect collision detection, which compares the images of the two sprites pixel-by-pixel.</p>
</li>
<li><p><strong><code>sprite.isTouching(otherSprite)</code></strong></p>
<p>Returns <code>true</code> if the two sprites are overlapping; <code>false</code> otherwise.</p>
</li>
<li><p><strong><code>sprite.isTouchingFast(otherSprite)</code></strong></p>
<p>The same as <code>isTouching</code>, but avoids the accurate-but-slow Scratch-like pixel-perfect collision detection, which compares the images of the two sprites pixel-by-pixel.</p>
</li>
<li><p><strong><code>sprite.touchesPoint(x, y)</code></strong></p>
<p>Returns <code>true</code> if the point overlaps the sprite; <code>false</code> otherwise.</p>
<p>You probably won‚Äôt need this, but it can be useful if you‚Äôre doing complicated things involving <code>drag</code> events.</p>
</li>
<li><p><strong><code>sprite.isTouchingEdge()</code></strong></p>
<p>Returns <code>true</code> if the sprite is near to the edge; <code>false</code> otherwise.</p>
</li>
<li><p><strong><code>sprite.isOnScreen()</code></strong></p>
<p>Returns <code>false</code> if the sprite is completely off the screen; <code>true</code> otherwise.</p>
<p>This takes into account scrolling.</p>
</li>
<li><p><strong><code>sprite.destroy()</code></strong></p>
<p>Remove the sprite from the screen. Afterwards, the sprite is ‚Äúdead‚Äù and you can‚Äôt use it anymore.</p>
<p>If you just want to hide the sprite for a moment, set its <code>opacity</code> to zero.</p>
</li>
</ul>
<h2 id="spriteforever">Sprite::forever</h2>
<p><code>forever</code> is really useful function: it lets you do something on every ‚Äúframe‚Äù or ‚Äútick‚Äù of your game. Usually ticks happen 60 times a second (60 FPS).</p>
<p>Write a <code>forever</code> block like so:</p>
<pre><code class="language-js">sprite.forever(() =&gt; {
    // do stuff
})</code></pre>
<p>Any code after the forever loop isn‚Äôt affected:</p>
<pre><code class="language-js">sprite.forever(() =&gt; {
    // This code runs forever.
})

// This code runs once.
// Carry on setting up the game:
var otherSprite = new Sprite</code></pre>
<p>When the Sprite is <strong>destroyed</strong>, the <code>forever</code> loop will stop.</p>
<p>If you want to <strong>stop</strong> a <code>forever</code> loop without destroying the Sprite (so that it doesn‚Äôt run forever!), you can <code>return false</code>:</p>
<pre><code class="language-js">player.forever(() =&gt; {
    if (player.isTouching(floor)) { // the floor is lava
        // game over!
        return false // stop this loop
    }
    // otherwise, move the player...
})</code></pre>
<h2 id="text">Text</h2>
<p>A <strong>Text</strong> object is like a Sprite, but instead of a costume, it‚Äôs used to display <em>text</em>.</p>
<pre><code>var label = new Text
label.text = &#39;SCORE: &#39; + 100</code></pre><p>The text has a retro aesthetic. It also supports <strong>emoji</strong> (using the same emoji set as Sprites can use). Which means that this:</p>
<pre><code class="language-js">var snowy = new Text
snowy.text = &#39;<img class="emojione" alt="‚õÑ" title=":snowman:" src="https://cdn.jsdelivr.net/emojione/assets/3.1/png/32/26c4.png"/>&#39;</code></pre>
<p>‚Ä¶is quite similar to this:</p>
<pre><code class="language-js">var snowy = new Sprite
snowy.costume = &#39;<img class="emojione" alt="‚õÑ" title=":snowman:" src="https://cdn.jsdelivr.net/emojione/assets/3.1/png/32/26c4.png"/>&#39;</code></pre>
<p><code>Text</code> objects have all the same attributes as a <a href="#sprite">Sprite</a>‚Äìbut instead of a <code>costume</code>, they have the following:</p>
<ul>
<li><p><strong><code>obj.text</code></strong></p>
<p>The text to display.</p>
</li>
<li><p><strong><code>obj.fill</code></strong></p>
<p>The color of the text, e.g. <code>text.fill = &#39;#007de0&#39;</code></p>
</li>
</ul>
<h2 id="polygon">Polygon</h2>
<p>A <strong>Polygon</strong> is like a Sprite, but has a <em>shape</em> instead of a costume. This shape is defined using a list of points. Examples include making a filled rectangle, a triangle with a fill and an outline, and thick lines.</p>
<img src="static/polygons.png" width=200>

<p>Here‚Äôs an example Polygon:</p>
<pre><code class="language-js">var p = new Polygon
p.points = [[0, 0], [0, 32], [32, 32], [32, 0]]
p.fill = &#39;#007de0&#39;
p.outline = &#39;black&#39;
p.thickness = 2</code></pre>
<p><code>Polygon</code>s have all the same attributes as a <a href="#sprite">Sprite</a>‚Äìbut instead of a <code>costume</code>, they have the following:</p>
<ul>
<li><p><strong><code>polygon.points</code></strong></p>
<p>A list of points. Each point is a 2-element list with the X and Y coordinates (relative to the polygon‚Äôs center), like so:</p>
<pre><code class="language-js">p.points = [[0, 0], [-16, 20], [16, 20]]</code></pre>
</li>
<li><p><strong><code>polygon.fill</code></strong></p>
<p>The color painted inside the shape, e.g. <code>polygon.fill = &#39;#007de0&#39;</code>.</p>
<p>Leave out this setting, or set it to <code>null</code>, for no fill (just an outline).</p>
</li>
<li><p><strong><code>polygon.outline</code></strong></p>
<p>The outline color, e.g. <code>polygon.outline = &#39;black&#39;</code>.</p>
<p>Leave out this setting, or set it to <code>null</code>, for no outline. You must specify <em>either</em> a fill or an outline (or both).</p>
</li>
<li><p><strong><code>polygon.thickness</code></strong></p>
<p>How thick to draw the outline (in pixels). Defaults to 2.</p>
</li>
<li><p><strong><code>polygon.closed</code></strong></p>
<p>Whether the last point should be joined to the first one, to make a closed shape.</p>
<p>Defaults to <code>true</code> for filled polygons. <strong>TODO:</strong> saner default handling.</p>
</li>
</ul>
<h2 id="rect">Rect</h2>
<p>A <code>Rect</code> is a special sort of <a href="#polygon">Polygon</a> which, unsurprisingly, is shaped like a rectangle.</p>
<p>Instead of a <code>costume</code>, <code>Rect</code>s have the following:</p>
<ul>
<li><p><strong><code>rect.width</code></strong> / <strong><code>rect.height</code></strong></p>
<p>The dimensions of the rectangle.</p>
</li>
<li><p><strong><code>rect.fill</code></strong> / <strong><code>rect.outline</code></strong> / <strong><code>rect.thickness</code></strong></p>
<p>The fill color, outline color, and width of the outline.</p>
<p>See <a href="#polygon">Polygon</a> for more details.</p>
</li>
</ul>
<h2 id="touch-events">Touch Events</h2>
<p>An <strong>event</strong> tells you that something has happened. Both Worlds and Sprites will emit events when they are tapped or dragged.</p>
<p>If a tap overlaps more than one sprite (because the sprites are overlapping), then the sprites are told about the events in order. The front-most one sees the event first.</p>
<p>If a sprite wants to handle an event, it should <code>return true</code>. From then on, no other sprites (nor the <code>world</code>!) will see the event.</p>
<p>There are a few kinds of event:</p>
<ul>
<li><p><strong><code>world.onTap(e =&gt; { ... })</code></strong> / <strong><code>sprite.onTap(e =&gt; { ... })</code></strong></p>
<p>A <code>tap</code> event happens when a finger is pressed against the screen and let go without moving.</p>
<p>The event object <code>e</code> has the following attributes:</p>
<ul>
<li><strong><code>e.fingerX</code></strong> / <strong><code>e.fingerY</code></strong>: the coordinates of the tap.</li>
</ul>
</li>
<li><p><strong><code>world.onDrag(e =&gt; { ... })</code></strong> / <strong><code>sprite.onDrag(e =&gt; { ... })</code></strong></p>
<p>The event object <code>e</code> has the following attributes:</p>
<ul>
<li><strong><code>e.startX</code></strong> / <strong><code>e.startY</code></strong>: the coordinate the drag started from.</li>
<li><strong><code>e.deltaX</code></strong> / <strong><code>e.deltaY</code></strong>: the amount the finger has moved since the last drag event.</li>
<li><strong><code>e.fingerX</code></strong> / <strong><code>e.fingerY</code></strong>: the current coordinates of the drag.</li>
</ul>
<p>If the Sprite doesn‚Äôt want to hear about the event anymore, it can <code>return false</code>.</p>
</li>
<li><p><strong><code>world.onDrop(e =&gt; { ... })</code></strong> / <strong><code>sprite.onDrop(e =&gt; { ... })</code></strong></p>
</li>
</ul>
<p>If you‚Äôre testing your game on a computer, mouse clicks and drags will work to simulate touches ‚Äì but remember that unlike fingers, a mouse pointer can only be in one place at a time!</p>
<h3 id="detecting-taps">Detecting taps</h3>
<pre><code class="language-js">world.onTap(e =&gt; {
    // make a ball where you clicked
    var ball = new Sprite
    ball.costume = &#39;beachball&#39;
    ball.posX = e.fingerX
    ball.posY = e.fingerY

    ball.onTap(e =&gt; {
        // flip
        ball.flipped = !ball.flipped

        // handle the event
        // - otherwise another ball will get spawned!
        return true
    })
})</code></pre>
<h3 id="dragging-sprites-around">Dragging sprites around</h3>
<pre><code class="language-js">var ball = new Sprite
ball.costume = &#39;beachball&#39;
ball.onDrag(e =&gt; {
    // move when dragged
    ball.posX += e.deltaX
    ball.posY += e.deltaY
    return true
})</code></pre>
<h2 id="touches-list">Touches list</h2>
<h3 id="detecting-fingers-held-down">Detecting fingers held down</h3>
<p>Sometimes you don‚Äôt want to listen for events: you just want to know where fingers are touching the screen, <strong>right now</strong>. To do this, you can use <code>getFingers()</code>.</p>
<ul>
<li><p><strong><code>world.getFingers()</code></strong></p>
<p>Returns an <code>Array</code> containing a list of each finger currently touching the screen.</p>
<p>You can use a <code>for...of</code> loop to go through each finger in turn:</p>
<pre><code class="language-js">for (let e of world.getFingers()) {
    if (e.fingerX &lt; world.width / 2) {
        // touching the left side of the screen
    } else if (e.fingerX &gt; world.width/ 2) {
        // touching the right side of the screen
    }
}</code></pre>
<p>Each finger is an <em>event</em> object, just like the <code>e</code> argument passed to <code>onTap</code> or <code>onDrag</code>.</p>
</li>
</ul>
<h2 id="phone">Phone</h2>
<p><code>Phone</code> provides access to sensors on a smartphone, such as the accelerometer. You can use this to control your game depending on how the phone is held; for example tilting to steer in a racing game.</p>
<p>You need to make a <code>Phone</code> object before you can access the readings:</p>
<pre><code class="language-js">var phone = new Phone</code></pre>
<p>It has the following attributes which you can get:</p>
<ul>
<li><p><strong><code>phone.zAngle</code></strong>: the angle of the phone‚Äôs screen in relation to the ground.</p>
<p>An angle of <code>0</code> means the phone is held upright. Tilt the phone to see it change.</p>
</li>
</ul>
<h2 id="sound">Sound</h2>
<p>To use sounds, make sure to <code>import {Sound} from &#39;you-win&#39;</code>.</p>
<p>To load a sound , use <code>loadSound</code>. See <a href="#assets">Assets</a> for details on the <code>static/</code> folder and where to put your sound files.</p>
<pre><code class="language-js">uw.loadSound(&#39;moo&#39;, &#39;/moo.wav&#39;)
await uw.begin()</code></pre>
<p>Before you can play your sound, you must create a <code>Sound</code> object.</p>
<pre><code class="language-js">var mooNoise = new Sound(&#39;moo&#39;)</code></pre>
<p>Finally, you can play your sound at the appropriate time.</p>
<pre><code class="language-js">mooNoise.play()</code></pre>
<h3 id="maths">Maths</h3>
<p>Some built-in maths utilities.</p>
<ul>
<li><p><strong><code>uw.range([start], end, [step])</code></strong></p>
<p>Return a list of numbers starting at <code>start</code> (default <code>0</code>), and ending before <code>end</code>. Behaves identically to Python‚Äôs <code>range()</code>.</p>
<p>The optional <code>step</code> argument (default <code>1</code>) is how much to move between each item. </p>
<pre><code class="language-js">uw.range(5) // =&gt; [0, 1, 2, 3, 4]
uw.range(5, 10) // =&gt; [5, 6, 7, 8, 9]
uw.range(10, 20, 2) // =&gt; [10, 12, 14, 16, 18]
uw.range(0, -5, -1) // =&gt; [0, -1, -2, -3, -4]</code></pre>
</li>
<li><p><strong><code>uw.dist(dx, dy)</code></strong></p>
<p>The distance between (0, 0) and (dx, dy), calculated using Pythagoras‚Äô Theorem.</p>
</li>
</ul>
<p>Some trigonometric functions. These work in degrees, unlike the ones built-in to JavaScript which use radians.</p>
<ul>
<li><strong><code>uw.sin(deg)</code></strong></li>
<li><strong><code>uw.cos(deg)</code></strong></li>
<li><strong><code>uw.atan2(x, y)</code></strong></li>
</ul>
<h3 id="random">Random</h3>
<p>Some built-in ways of getting random things are included.</p>
<ul>
<li><p><strong><code>uw.randomInt(from, to)</code></strong></p>
<p>Return a random integer (whole number) between <code>from</code> and <code>to</code>, inclusive.</p>
<pre><code class="language-js">uw.randomInt(1, 3) // =&gt; 2
uw.randomInt(1, 3) // =&gt; 1
uw.randomInt(1, 3) // =&gt; 3</code></pre>
</li>
<li><p><strong><code>uw.randomChoice(array)</code></strong></p>
<p>Return a randomly-selected item of an array.</p>
<pre><code class="language-js">uw.randomChoice([&#39;<img class="emojione" alt="üêÑ" title=":cow2:" src="https://cdn.jsdelivr.net/emojione/assets/3.1/png/32/1f404.png"/>&#39;, &#39;<img class="emojione" alt="üêë" title=":sheep:" src="https://cdn.jsdelivr.net/emojione/assets/3.1/png/32/1f411.png"/>&#39;, &#39;<img class="emojione" alt="üêé" title=":racehorse:" src="https://cdn.jsdelivr.net/emojione/assets/3.1/png/32/1f40e.png"/>&#39;]) // =&gt; &#39;<img class="emojione" alt="üêë" title=":sheep:" src="https://cdn.jsdelivr.net/emojione/assets/3.1/png/32/1f411.png"/>&#39;</code></pre>
</li>
</ul>

</div>

<script async id=highlight-js src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
document.querySelector('#highlight-js').addEventListener('load', function() {
    [].slice.apply(document.querySelectorAll('pre code')).forEach(function(b) {
        hljs.highlightBlock(b)
    })
})
</script>

<script async src="static/scroll.js"></script>

